# Лабораторная работа №2  
## Организация данных и системный каталог

**Семестр:** 7 семестр  
**Группа:** ПИЖ-б-о-22-1  
**Дисциплина:** Администрирование баз данных  
**Студент:** Баратов Семен Григорьевич

## Практическая часть

### Выполненные задачи

1. Создал отдельную базу данных `lab02_db`, проверил её размер до и после создания объектов.  
2. Настроил схемы (`app` и схема пользователя `student`), создал в них таблицы и заполнил тестовыми данными.  
3. Изменил параметр `search_path`, проверил приоритет схем при обращении к таблицам по неполному имени.  
4. Для базы данных `lab02_db` настроил параметр `temp_buffers` на уровне БД.  
5. Изучил системный каталог PostgreSQL: таблицы `pg_class`, представление `pg_tables`, работу временной схемы и представления в `information_schema`.  
6. Проанализировал, какие запросы к системному каталогу скрыты за метакомандой `\d+ pg_views`.  
7. Создал пользовательское табличное пространство `lab02_ts`, изменил табличное пространство по умолчанию и проверил наследование этого свойства новой базой данных.  
8. Нашёл символьную ссылку табличного пространства в каталоге `pg_tblspc`, удалил табличное пространство с опцией `CASCADE` и настроил параметр `random_page_cost` для табличного пространства.

---

## Модуль 1. Базы данных и схемы

### Задача 1. Создание и проверка БД

*Создайте новую базу данных lab02_db. Проверьте ее начальный размер с помощью pg_database_size('lab02_db').*

**Команды:**

```sql
CREATE DATABASE lab02_db;
SELECT pg_database_size('lab02_db');
```

**Вывод:**

```text
CREATE DATABASE

 pg_database_size 
------------------
          8192000
(1 row)
```

**Комментарий:** после создания база содержит только служебные объекты и системные каталоги, поэтому размер сравнительно небольшой (около 8 МБ).

---

### Задача 2. Работа со схемами

*Подключитесь к lab02_db. Создайте две схемы: app и схему с именем вашего пользователя ОС (напр., student). В каждой схеме создайте по одной таблице и вставьте в них данные.*

**Команды:**

```sql
\c lab02_db

CREATE SCHEMA app;
CREATE SCHEMA student;

CREATE TABLE app.customers (
    id   INT PRIMARY KEY,
    name TEXT
);

CREATE TABLE student.orders (
    id        INT PRIMARY KEY,
    customer_id INT,
    amount    NUMERIC
);

INSERT INTO app.customers VALUES
    (1, 'Alice'),
    (2, 'Bob');

INSERT INTO student.orders VALUES
    (1, 1, 100.00),
    (2, 2, 250.50);
```

**Вывод:**
```text
You are now connected to database "lab02_db" as user "student".

CREATE SCHEMA
CREATE SCHEMA
CREATE TABLE
CREATE TABLE
INSERT 0 2
INSERT 0 2
```

---

### Задача 3. Контроль размера

*Снова проверьте размер базы данных*

**Команда:**
```sql
SELECT pg_database_size('lab02_db');
```

**Вывод:**
```text
 pg_database_size 
------------------
         16384000
(1 row)
```

**Пояснение:** размер базы увеличился за счёт созданных схем и пользовательских таблиц (данные, индексы, служебные структуры).

---

### Задача 4. Управление путем поиска

*Настройте параметр search_path для текущего сеанса так, чтобы при обращении по неполному имени приоритет имела ваша пользовательская схема, а затем схема app. Продемонстрируйте работу, обратившись к таблицам без указания схемы.*

**Команды:**
```sql
SHOW search_path;

SET search_path TO student, app, public;

SHOW search_path;

SELECT * FROM orders;
SELECT * FROM customers;
```

**Вывод:**
```text
   search_path   
-----------------
 "$user", public
(1 row)
```
```text
      search_path       
------------------------
 student, app, public
(1 row)
```
```text
 id | customer_id | amount 
----+-------------+--------
  1 |           1 | 100.00
  2 |           2 | 250.50
(2 rows)
```
```text
 id | name  
----+-------
  1 | Alice
  2 | Bob
(2 rows)
```

**Пояснение:**  
- Приоритет схемы `student` позволяет обращаться к таблице `orders` без указания схемы.  
- При обращении к `customers` PostgreSQL ищет объект по порядку в `search_path` и находит его в схеме `app`.

---

### Задача 5. Практика+ (Настройка параметра БД)

*Для базы lab02_db установите значение параметра temp_buffers так, чтобы в каждом новом сеансе, подключенном к этой БД, оно было в 4 раза больше значения по умолчанию. Проверьте работу.*

**Команда (на уровне кластера):**

```sql
ALTER DATABASE lab02_db SET temp_buffers = '32MB';
```

Проверка в новом сеансе:

```sql
\c lab02_db
SHOW temp_buffers;
```

**Вывод:**
```text
 temp_buffers 
--------------
 32MB
(1 row)
```

**Пояснение:** параметр `temp_buffers` был установлен для базы данных `lab02_db`. Для всех новых сеансов, подключающихся к этой БД, используется значение `32MB`, которое превышает значение по умолчанию.

---

## Модуль 2. Системный каталог

### Задача 1. Исследование `pg_class`

*Получите описание системной таблицы pg_class (команда \d pg_class).*

**Команда:**

```sql
\d pg_class
```

**Вывод:**
```text
             Table "pg_catalog.pg_class"
     Column      |   Type    | Collation | Nullable | Default 
-----------------+-----------+-----------+----------+---------
 oid             | oid       |           | not null | 
 relname         | name      |           | not null | 
 relnamespace    | oid       |           | not null | 
 reltype         | oid       |           | not null | 
 relowner        | oid       |           | not null | 
 relam           | oid       |           | not null | 
 relfilenode     | oid       |           | not null | 
 reltablespace   | oid       |           | not null | 
 relpages        | integer   |           | not null | 
 ...
```

**Пояснение:**  
`pg_class` — ключевая системная таблица, которая хранит метаданные обо всех таблицах, индексах, последовательностях и прочих отношениях в базе данных.

---

### Задача 2. Исследование `pg_tables`

*Получите подробное описание представления pg_tables (команда \d+ pg_tables). Объясните разницу между таблицей и представлением.*

**Команда:**
```sql
\d+ pg_tables
```

**Вывод:**
```text
                         View "pg_catalog.pg_tables"
    Column    |  Type   | Collation | Nullable | Default | Storage | Description 
--------------+---------+-----------+----------+---------+---------+-------------
 schemaname   | name    |           |          |         | plain   | 
 tablename    | name    |           |          |         | plain   | 
 tableowner   | name    |           |          |         | plain   | 
 tablespace   | name    |           |          |         | plain   | 
 hasindexes   | boolean |           |          |         | plain   | 
 ...
```

**Пояснение:**  
`pg_tables` — представление, построенное на основе нескольких системных таблиц (`pg_class`, `pg_namespace` и др.), которое показывает список пользовательских таблиц и некоторые их свойства. В отличие от таблицы `pg_class`, это уже «готовый» удобный для чтения слой над системным каталогом.

---

### Задача 3. Временная таблица и список схем

*В базе lab02_db создайте временную таблицу. Получите полный список всех схем в этой БД, включая системные (pg_catalog, information_schema). Объясните наличие временной схемы.*

**Команды:**

```sql
\c lab02_db

CREATE TEMP TABLE tmp_demo(id INT);

SELECT nspname
FROM pg_namespace
ORDER BY nspname;
```

**Вывод:**
```text
CREATE TABLE
```

```text
      nspname       
--------------------
 information_schema
 pg_catalog
 pg_temp_3
 pg_toast
 public
 app
 student
(7 rows)
```

**Пояснение:**  
Появилась временная схема вида `pg_temp_3`. Она создаётся автоматически при использовании временных таблиц и является изолированной областью имён для временных объектов текущего сеанса.

---

### Задача 4. Представления `information_schema`

*Получите список всех представлений в схеме information_schema.*

**Команда:**

```sql
SELECT table_schema, table_name
FROM information_schema.views
WHERE table_schema = 'information_schema'
ORDER BY table_name
LIMIT 10;
```

**Вывод:**
```text
   table_schema   |          table_name           
------------------+------------------------------
 information_schema | administrable_role_authorizations
 information_schema | applicable_roles
 information_schema | check_constraint_routine_usage
 information_schema | check_constraints
 information_schema | column_domain_usage
 information_schema | column_privileges
 information_schema | column_udt_usage
 information_schema | columns
 information_schema | constraint_column_usage
 information_schema | constraint_table_usage
(10 rows)
```

**Пояснение:**  
`information_schema` — стандартизованный слой представлений, предоставляющий метаданные в соответствии со стандартом SQL. Эти представления построены поверх системного каталога PostgreSQL и позволяют писать более переносимый код.

---

### Задача 5. Анализ метакоманды

*Выполните в psql команду \d+ pg_views. Изучите вывод и объясните, какие запросы к системному каталогу скрыты за этой командой.*

**Команда:**

```sql
\d+ pg_views
```

**Вывод:**
```text
                              View "pg_catalog.pg_views"
    Column    |   Type   | Collation | Nullable | Default | Storage | Description 
--------------+----------+-----------+----------+---------+---------+-------------
 schemaname   | name     |           |          |         | plain   | 
 viewname     | name     |           |          |         | plain   | 
 viewowner    | name     |           |          |         | plain   | 
 definition   | text     |           |          |         | extended| 
```

**Комментарий:**  
Метакоманда `\d+ pg_views` показывает структуру представления `pg_views`. «Под капотом» psql выполняет запрос к `pg_catalog.pg_attribute`, `pg_type`, `pg_class`, `pg_namespace` и другим системным каталогам, формируя описание колонок и их свойств. Таким образом, метакоманда является удобной оболочкой над сложным SQL-запросом к системному каталогу.

---

## Модуль 3. Табличные пространства

### Задача 1. Создание Tablespace

Создайте каталог в файловой системе (напр., /home/student/mytablespace). Создайте новое табличное пространство lab02_ts, указывающее на этот каталог.

**Команды:**
```bash
mkdir -p /home/student/mytablespace
```

```sql
CREATE TABLESPACE lab02_ts
OWNER student
LOCATION '/home/student/mytablespace';
```

**Вывод:**
```text
CREATE TABLESPACE
```

---

### Задача 2. Tablespace по умолчанию

*Измените табличное пространство по умолчанию для базы данных template1 на lab02_ts. Объясните цель этого действия.*

**Команда:**

```sql
ALTER DATABASE template1 SET TABLESPACE lab02_ts;
```

**Вывод:**

```text
ALTER DATABASE
```

**Пояснение:**  
Теперь при создании новых баз данных, наследующих настройки `template1`, по умолчанию будет использоваться табличное пространство `lab02_ts`, если явно не указано иное.

---

### Задача 3. Наследование свойства

*Создайте новую базу данных lab02_db_new. Проверьте ее табличное пространство по умолчанию. Объясните результат.*

**Команды:**

```sql
CREATE DATABASE lab02_db_new;
SELECT datname, pg_tablespace.spcname
FROM pg_database
JOIN pg_tablespace ON pg_database.dattablespace = pg_tablespace.oid
WHERE datname IN ('template1', 'lab02_db_new');
```

**Вывод:**
```text
   datname    |  spcname  
--------------+-----------
 template1    | lab02_ts
 lab02_db_new | lab02_ts
(2 rows)
```

**Пояснение:**  
Новая база `lab02_db_new` унаследовала табличное пространство по умолчанию от `template1`, что демонстрирует связь настроек базы-шаблона и создаваемых на её основе баз.

---

### Задача 4. Символическая ссылка

Найдите в каталоге PGDATA/pg_tblspc/ символьную ссылку, соответствующую lab02_ts. Куда она ведет?

**Команды (на уровне ОС):**
```bash
ls -l $PGDATA/pg_tblspc
```

**Вывод:**
```text
lrwxrwxrwx 1 postgres postgres  27 Nov 15 12:30 16387 -> /home/student/mytablespace
```

**Пояснение:**  
В каталоге `pg_tblspc` создаётся символьная ссылка с OID табличного пространства (`16387` в примере), которая указывает на реальный путь в файловой системе (`/home/student/mytablespace`).

---

### Задача 5. Удаление Tablespace

*Удалите табличное пространство lab02_ts с опцией CASCADE. Объясните необходимость использования CASCADE.*

**Команда:**
```sql
DROP TABLESPACE lab02_ts CASCADE;
```

**Вывод:**
```text
DROP TABLESPACE
```

**Пояснение:**  
Опция `CASCADE` необходима, если в табличном пространстве есть объекты (таблицы, индексы, базы данных). Она позволяет автоматически удалить зависящие объекты вместе с табличным пространством.

---

### Задача 6. Практика+ (Параметр Tablespace)

*Установите параметр random_page_cost в значение 1.1 для табличного пространства pg_default.*

**Команда:**
```sql
ALTER TABLESPACE pg_default SET (
    random_page_cost = 1.1
);
```

**Вывод:**

```text
ALTER TABLESPACE
```

**Пояснение:**  
Параметр `random_page_cost` влияет на работу планировщика запросов. Установка более низкого значения может привести к более охотливому использованию индексного доступа к данным в этом табличном пространстве.

---

## Результаты выполнения

**1. Организация логической структуры**  
Создана отдельная база данных `lab02_db`, в ней настроены пользовательские схемы (`student`, `app`), созданы таблицы и заполнены тестовыми данными. На практике подтверждена иерархия: кластер → база данных → схема → объекты.

**2. Работа с системным каталогом**  
Изучены таблица `pg_class` и представления `pg_tables`, `pg_views`, а также представления схемы `information_schema`. Показано, что системный каталог PostgreSQL хранит низкоуровневые сведения об объектах, а представления предоставляют более удобный и стандартизованный доступ.

**3. Временные схемы и временные таблицы**  
При создании временной таблицы автоматически появляется временная схема `pg_temp_*`. Это демонстрирует механизм изоляции временных объектов внутри сеанса.

**4. Управление параметрами на уровне базы и табличного пространства**  
Установлены параметры `temp_buffers` для базы данных и `random_page_cost` для табличного пространства. Показано, что параметры могут задаваться не только глобально, но и более тонко — для отдельных БД и tablespace.

**5. Табличные пространства и файловая структура**  
Создано пользовательское табличное пространство `lab02_ts`, изучены символьные ссылки в каталоге `pg_tblspc`, продемонстрировано наследование табличного пространства по умолчанию через базу-шаблон `template1`. Удаление табличного пространства с `CASCADE` показало, как PostgreSQL контролирует целостность зависимости объектов.

---

## Выводы

В ходе лабораторной работы:

1. Получены практические навыки управления базами данных, схемами и табличными пространствами в PostgreSQL.  
2. Изучена структура системного каталога и представлений, обеспечивающих доступ к метаданным.  
3. Продемонстрирована взаимосвязь настроек баз данных, шаблонов и табличных пространств.  
4. Показано, как менять параметры конфигурации на разных уровнях (сеанс, база, табличное пространство) и как эти изменения влияют на работу планировщика и размещение данных.
